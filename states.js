// Generated by CoffeeScript 1.9.1
(function() {
  "use strict";
  var States, createStates,
    slice = [].slice;

  createStates = function() {
    var States, _;
    if (!(_ = typeof window !== "undefined" && window !== null ? window.Types : void 0)) {
      _ = require('types.js');
    }
    if (_) {
      return States = (function() {
        var limit;

        limit = function(value, min, max) {
          if (value > max) {
            return max;
          }
          if (value < min) {
            return min;
          }
          return value;
        };

        function States(init) {
          init = _.forceObject(init);
          this.min = _.forceNumber(init['min'], 1);
          this.current = _.forceNumber(init['current'], this.min);
          this.stepSize = _.forceNumber(init['stepSize'], 1);
          this.setMax(init['max'] || this.min);
          this.up = _.forceBoolean(init['up'], true);
          this.pattern = _.forceString(init['pattern'], 'limit');
          this.delay = _.forceNumber(init['delay'], 1000);
          this.events = {};
          this.defaultEvent = function() {
            return '';
          };
        }

        States.prototype.setStep = function(newStep) {
          if (newStep == null) {
            newStep = this.stepSize;
          }
          return this.stepSize = limit(newStep, 1, this.range);
        };

        States.prototype.updateRange = function() {
          this.current = limit(this.current, this.min, this.max);
          this.range = (this.max + 1) - this.min;
          this.setStep();
          return this.range;
        };

        States.prototype.setMin = function(newMin) {
          newMin = _.forceNumber(newMin);
          if (!newMin["void"]) {
            this.min = limit(newMin, newMin, this.max);
            this.updateRange();
          }
          return this.min;
        };

        States.prototype.setMax = function(newMax) {
          newMax = _.forceNumber(newMax);
          if (!newMax["void"]) {
            this.max = newMax;
            this.min = limit(this.min, this.min, this.max);
            this.updateRange();
          }
          return this.max;
        };

        States.prototype.setCurrent = function(newCurrent) {
          newCurrent = _.forceNumber(newCurrent);
          if (newCurrent["void"]) {
            return this.current;
          }
          return this.current = limit(newCurrent, this.min, this.max);
        };

        States.prototype.limit = function(step) {
          return limit(this.current + step, this.min, this.max);
        };

        States.prototype.rotate = function(step) {
          var current;
          current = this.current + step;
          if (current < this.min) {
            return this.max - (this.min - (current + 1));
          }
          if (current > this.max) {
            return this.min + ((current - 1) - this.max);
          }
          return current;
        };

        States.prototype.yoyo = function() {
          var next, prev;
          if (this.range === this.stepSize) {
            if (this.up) {
              return this.max;
            } else {

            }
            return this.min;
          }
          next = this.current + this.stepSize;
          if (this.up && (next > this.max)) {
            this.up = false;
            return this.max - (next - this.max);
          }
          prev = this.current - this.stepSize;
          if (!this.up && (prev < this.min)) {
            this.up = true;
            return this.min - (prev - this.min);
          }
          if (this.up) {
            return next;
          }
          return prev;
        };

        States.prototype.random = function() {
          return this.current = ((Math.random(this.range) * this.range) | 0) + this.min;
        };

        States.prototype.peek = function(amount) {
          switch (amount) {
            case void 0:
              amount = this.stepSize;
              break;
            case false:
              amount = -this.stepSize;
              break;
            default:
              (function(_this) {
                return (function() {
                  amount = _.forceNumber(amount, 0);
                  if ((Math.abs(amount)) >= _this.range) {
                    return amount = 0;
                  }
                });
              })(this)();
          }
          return this[this.pattern](amount);
        };

        States.prototype.eachStep = function(stepSize, callback) {
          var i, index, max, min, ref, ref1, ref2, ref3, results;
          if (stepSize == null) {
            stepSize = this.stepSize;
          }
          if (_.isFunction(stepSize)) {
            callback = stepSize;
            stepSize = this.stepSize;
          }
          if (stepSize < 0) {
            stepSize = Math.abs(stepSize);
            ref = [this.max, this.min], min = ref[0], max = ref[1];
          } else {
            ref1 = [this.min, this.max], min = ref1[0], max = ref1[1];
          }
          results = [];
          for (index = i = ref2 = min, ref3 = max; ref2 <= ref3 ? i <= ref3 : i >= ref3; index = ref2 <= ref3 ? ++i : --i) {
            if (index % stepSize === 0) {
              if (!callback) {
                results.push(index);
              } else {
                results.push(callback(index));
              }
            }
          }
          return results;
        };

        States.prototype.each = function(callback) {
          return this.eachStep(1, callback);
        };

        States.prototype.addEvent = function(index, callback) {
          return this.events[index] = callback;
        };

        States.prototype.removeEvent = function(index) {
          return delete this.events[index];
        };

        States.prototype.call = function() {
          var args, index;
          index = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          if (index == null) {
            index = this.current;
          }
          args.unshift(index);
          return _.forceFunction(this.events[index], (function(_this) {
            return function() {
              return _this.defaultEvent(args);
            };
          })(this)).apply(null, args);
        };

        States.prototype.next = function() {
          return this.current = this[this.pattern](this.stepSize);
        };

        States.prototype.nextCall = function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return this.call(this.next(), args);
        };

        States.prototype.prev = function() {
          return this.current = this[this.pattern](-this.stepSize);
        };

        States.prototype.prevCall = function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return this.call(this.prev(), args);
        };

        States.prototype.run = function(index) {
          var down;
          down = index < 0;
          if (!this.interval) {
            index = this.setCurrent(index);
            return this.interval = setInterval((function(_this) {
              return function() {
                if (down) {
                  return _this.call(_this.prev());
                } else {
                  return _this.call(_this.next());
                }
              };
            })(this), this.delay);
          }
        };

        States.prototype.stop = function() {
          return this.interval |= clearInterval(this.interval);
        };

        return States;

      })();
    }
  };

  if (States = createStates()) {
    if ((typeof define !== "undefined" && define !== null) && ('function' === typeof define) && define.amd) {
      define('states', [], function() {
        return States;
      });
    } else if (typeof module !== 'undefined') {
      module.exports = States;
    } else if (typeof window !== 'undefined') {
      window.States = States;
    }
  }

}).call(this);

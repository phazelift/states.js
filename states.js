// Generated by CoffeeScript 1.9.1
(function() {
  "use strict";
  var States, _,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  if ((typeof window !== "undefined" && window !== null)) {
    _ = window.Types;
  } else if (typeof module !== "undefined" && module !== null) {
    _ = require('types.js');
  }

  if (!_) {
    throw new Error('states.js cannot initialize, the required types.js was not found!');
  }

  States = (function() {
    var ALL_PATTERNS, limit;

    ALL_PATTERNS = ['limit', 'rotate', 'yoyo', 'random'];

    limit = function(value, min, max) {
      if (value > max) {
        return max;
      }
      if (value < min) {
        return min;
      }
      return value;
    };

    function States(init) {
      init = _.forceObject(init);
      this.min = _.forceNumber(init['min'], 1);
      this.current = _.forceNumber(init['current'], this.min);
      this.stepSize = _.forceNumber(init['stepSize'], 1);
      this.range = 1;
      this.setMax(init['max'] || this.min);
      this.up = _.forceBoolean(init['up'], true);
      this.pattern = this.setPattern();
      this.delay = _.forceNumber(init['delay'], 1000);
      this.events = {};
      this.defaultEvent = function() {
        return '';
      };
      this.lastCallResult = void 0;
    }

    States.prototype.setStep = function(newStep) {
      if (newStep == null) {
        newStep = this.stepSize;
      }
      return this.stepSize = limit(newStep, 1, this.range);
    };

    States.prototype._updateRange = function() {
      this.current = limit(this.current, this.min, this.max);
      this.range = (this.max + 1) - this.min;
      this.setStep();
      return this.range;
    };

    States.prototype.setMin = function(newMin) {
      newMin = _.forceNumber(newMin);
      if (!newMin["void"]) {
        this.min = limit(newMin, newMin, this.max);
        this._updateRange();
      }
      return this.min;
    };

    States.prototype.setMax = function(newMax) {
      newMax = _.forceNumber(newMax);
      if (!newMax["void"]) {
        this.max = newMax;
        this.min = limit(this.min, this.min, this.max);
        this._updateRange();
      }
      return this.max;
    };

    States.prototype.setPattern = function(pattern) {
      pattern = _.forceString(pattern);
      if (indexOf.call(ALL_PATTERNS, pattern) >= 0) {
        this.pattern = '_' + pattern;
        return pattern;
      } else {
        this.pattern = '_limit';
        return 'limit';
      }
    };

    States.prototype.setCurrent = function(newCurrent) {
      newCurrent = _.forceNumber(newCurrent);
      if (newCurrent["void"]) {
        return this.current;
      }
      return this.current = limit(newCurrent, this.min, this.max);
    };

    States.prototype._limit = function(step) {
      return limit(this.current + step, this.min, this.max);
    };

    States.prototype._rotate = function(step) {
      var current;
      current = this.current + step;
      if (current < this.min) {
        return this.max - (this.min - (current + 1));
      }
      if (current > this.max) {
        return this.min + ((current - 1) - this.max);
      }
      return current;
    };

    States.prototype._yoyo = function() {
      var next, prev;
      if (this.range === this.stepSize) {
        if (this.up) {
          return this.max;
        } else {

        }
        return this.min;
      }
      next = this.current + this.stepSize;
      if (this.up && (next > this.max)) {
        this.up = false;
        return this.max - (next - this.max);
      }
      prev = this.current - this.stepSize;
      if (!this.up && (prev < this.min)) {
        this.up = true;
        return this.min - (prev - this.min);
      }
      if (this.up) {
        return next;
      }
      return prev;
    };

    States.prototype._random = function() {
      return this.current = ((Math.random(this.range) * this.range) | 0) + this.min;
    };

    States.prototype.peek = function(step) {
      switch (step) {
        case void 0:
          step = this.stepSize;
          break;
        case false:
          step = -this.stepSize;
          break;
        default:
          (function(_this) {
            return (function() {
              step = _.forceNumber(step, 0);
              if ((Math.abs(step)) >= _this.range) {
                return step = 0;
              }
            });
          })(this)();
      }
      return this[this.pattern](step);
    };

    States.prototype.eachStep = function(stepSize, callback) {
      var i, index, max, min, ref, ref1, ref2, ref3, results;
      if (stepSize == null) {
        stepSize = this.stepSize;
      }
      if (_.isFunction(stepSize)) {
        callback = stepSize;
        stepSize = this.stepSize;
      }
      if (stepSize < 0) {
        stepSize = Math.abs(stepSize);
        ref = [this.max, this.min], min = ref[0], max = ref[1];
      } else {
        ref1 = [this.min, this.max], min = ref1[0], max = ref1[1];
      }
      results = [];
      for (index = i = ref2 = min, ref3 = max; ref2 <= ref3 ? i <= ref3 : i >= ref3; index = ref2 <= ref3 ? ++i : --i) {
        if (index % stepSize === 0) {
          if (!callback) {
            results.push(index);
          } else {
            results.push(callback(index));
          }
        }
      }
      return results;
    };

    States.prototype.each = function(callback) {
      return this.eachStep(1, callback);
    };

    States.prototype.addEvent = function(index, callback) {
      var ref;
      this.events[index] = callback;
      return (index >= (ref = this.min) && ref <= this.max);
    };

    States.prototype.removeEvent = function(index) {
      return delete this.events[index];
    };

    States.prototype.call = function() {
      var args, index;
      index = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (index == null) {
        index = this.current;
      }
      args.unshift(index);
      return _.forceFunction(this.events[index], (function(_this) {
        return function() {
          return _this.defaultEvent(args);
        };
      })(this)).apply(null, args);
    };

    States.prototype.next = function() {
      return this.current = this[this.pattern](this.stepSize);
    };

    States.prototype.nextCall = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return this.call(this.next(), args);
    };

    States.prototype.prev = function() {
      return this.current = this[this.pattern](-this.stepSize);
    };

    States.prototype.prevCall = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return this.call(this.prev(), args);
    };

    States.prototype.run = function(index) {
      var down;
      down = index < 0;
      if (!this.interval) {
        index = this.setCurrent(index);
        return this.interval = setInterval((function(_this) {
          return function() {
            if (down) {
              return _this.lastCallResult = _this.call(_this.prev());
            } else {
              return _this.lastCallResult = _this.call(_this.next());
            }
          };
        })(this), this.delay);
      }
    };

    States.prototype.stop = function() {
      return this.interval |= clearInterval(this.interval);
    };

    return States;

  })();

  if ((typeof define !== "undefined" && define !== null) && ('function' === typeof define) && define.amd) {
    define('states', [], function() {
      return States;
    });
  } else if (typeof module !== "undefined" && module !== null) {
    module.exports = States;
  } else if (typeof window !== "undefined" && window !== null) {
    window.States = States;
  }

}).call(this);
